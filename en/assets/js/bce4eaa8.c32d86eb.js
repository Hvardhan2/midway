"use strict";(self.webpackChunkmy_website=self.webpackChunkmy_website||[]).push([[2848],{3905:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>m});var a=n(7294);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function r(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function o(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?r(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):r(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=a.createContext({}),l=function(e){var t=a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):o(o({},t),e)),n},p=function(e){var t=l(e.components);return a.createElement(c.Provider,{value:t},e.children)},d={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},u=a.forwardRef((function(e,t){var n=e.components,i=e.mdxType,r=e.originalType,c=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),u=l(n),m=i,h=u["".concat(c,".").concat(m)]||u[m]||d[m]||r;return n?a.createElement(h,o(o({ref:t},p),{},{components:n})):a.createElement(h,o({ref:t},p))}));function m(e,t){var n=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=n.length,o=new Array(r);o[0]=u;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s.mdxType="string"==typeof e?e:i,o[1]=s;for(var l=2;l<r;l++)o[l]=n[l];return a.createElement.apply(null,o)}return a.createElement.apply(null,n)}u.displayName="MDXCreateElement"},4459:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>o,default:()=>d,frontMatter:()=>r,metadata:()=>s,toc:()=>l});var a=n(7462),i=(n(7294),n(3905));const r={},o="Dependency injection",s={unversionedId:"container",id:"container",title:"Dependency injection",description:"Midway uses a lot of dependency injection features. Through the lightweight features of decorators, dependency injection becomes elegant, thus making the development process convenient and interesting.",source:"@site/i18n/en/docusaurus-plugin-content-docs/current/container.md",sourceDirName:".",slug:"/container",permalink:"/en/docs/container",draft:!1,editUrl:"https://github.com/midwayjs/midway/tree/main/site/docs/container.md",tags:[],version:"current",frontMatter:{},sidebar:"common",previous:{title:"Start-up and deployment",permalink:"/en/docs/deployment"},next:{title:"Test",permalink:"/en/docs/testing"}},c={},l=[{value:"Dependency injection principle",id:"dependency-injection-principle",level:2},{value:"Dependency injection scope",id:"dependency-injection-scope",level:2},{value:"Configure scope",id:"configure-scope",level:3},{value:"Singleton scope",id:"singleton-scope",level:3},{value:"Request scope",id:"request-scope",level:3},{value:"Scope cache",id:"scope-cache",level:3},{value:"Scope downgrade",id:"scope-downgrade",level:3},{value:"Injection rule",id:"injection-rule",level:2},{value:"Class-based injection",id:"class-based-injection",level:3},{value:"Injection Based on fixed name",id:"injection-based-on-fixed-name",level:3},{value:"Injection Based on Attribute Name",id:"injection-based-on-attribute-name",level:3},{value:"Inject existing objects",id:"inject-existing-objects",level:3},{value:"Inject default identifier",id:"inject-default-identifier",level:3},{value:"Get the dependency injection container",id:"get-the-dependency-injection-container",level:2},{value:"Get from @ApplicationContext() decorator",id:"get-from-applicationcontext-decorator",level:3},{value:"Get from app",id:"get-from-app",level:3},{value:"Get in Configuration",id:"get-in-configuration",level:3},{value:"Dynamic API",id:"dynamic-api",level:2},{value:"Dynamic acquisition of instances",id:"dynamic-acquisition-of-instances",level:3},{value:"Pass constructor parameters",id:"pass-constructor-parameters",level:3},{value:"Dynamic function injection",id:"dynamic-function-injection",level:3},{value:"Static API",id:"static-api",level:2},{value:"Automatic binding",id:"automatic-binding",level:2},{value:"Object lifecycle",id:"object-lifecycle",level:2},{value:"Asynchronous initialization",id:"asynchronous-initialization",level:3},{value:"Asynchronous destruction",id:"asynchronous-destruction",level:3},{value:"Common usage errors",id:"common-usage-errors",level:2},{value:"Error: Get Injection Property in Constructor",id:"error-get-injection-property-in-constructor",level:3},{value:"On inheritance",id:"on-inheritance",level:3}],p={toc:l};function d(e){let{components:t,...n}=e;return(0,i.kt)("wrapper",(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"dependency-injection"},"Dependency injection"),(0,i.kt)("p",null,"Midway uses a lot of dependency injection features. Through the lightweight features of decorators, dependency injection becomes elegant, thus making the development process convenient and interesting."),(0,i.kt)("p",null,"Dependency injection is a very important core in the Java Spring system, and we explain this capability in a simple way."),(0,i.kt)("p",null,"As an example, take the following function directory structure as an example."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},".\n\u251c\u2500\u2500 package.json\n\u251c\u2500\u2500 src\n\u2502   \u251c\u2500\u2500 controller                                          # Controller directory\n\u2502   \u2502   \u2514\u2500\u2500 user.controller.ts\n\u2502   \u2514\u2500\u2500 service                                             # Service Directory\n\u2502       \u2514\u2500\u2500 user.service.ts\n\u2514\u2500\u2500 tsconfig.json\n")),(0,i.kt)("p",null,"In the above example, two files, ",(0,i.kt)("inlineCode",{parentName:"p"},"user.controller.ts")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"user.service.ts"),", are provided."),(0,i.kt)("admonition",{type:"tip"},(0,i.kt)("p",{parentName:"admonition"},"In the following example, in order to show the complete function, we will write a complete ",(0,i.kt)("inlineCode",{parentName:"p"},"@Provide")," decorator, but in actual use, if there are other decorators (such as ",(0,i.kt)("inlineCode",{parentName:"p"},"@Controller"),"), ",(0,i.kt)("inlineCode",{parentName:"p"},"@Provide")," can be used Omit.")),(0,i.kt)("p",null,"For the convenience of explanation, we merged it together, and the content is roughly as follows."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import { Provide, Inject, Get } from '@midwayjs/decorator';\n\n// user.controller.ts\n@Provide() // Actually can be omitted\n@Controller()\nexport class UserController {\n\n  @Inject()\n  userService: UserService;\n\n  @Get('/')\n  async get() {\n    const user = await this.userService.getUser();\n    console.log(user);      // world\n  }\n}\n\n// user.service.ts\n@Provide()\nexport class UserService {\n  async getUser() {\n    return 'world';\n  }\n}\n\n")),(0,i.kt)("p",null,"Leaving aside all the decorators, you can see that this is the standard Class writing and there is no other extra content. This is also the core capability of Midway system and the most fascinating place to rely on injection."),(0,i.kt)("p",null,"What ",(0,i.kt)("inlineCode",{parentName:"p"},"@Provide")," does is tell the ",(0,i.kt)("strong",{parentName:"p"},"dependency injection container")," that I need to be loaded by the container. The ",(0,i.kt)("inlineCode",{parentName:"p"},"@Inject")," decorator tells the container that I need to inject an instance into the property."),(0,i.kt)("p",null,"Through the matching of these two decorators, we can easily get the instance object in any class, just like ",(0,i.kt)("inlineCode",{parentName:"p"},"this.userService")," above."),(0,i.kt)("p",null,(0,i.kt)("strong",{parentName:"p"},"Note"),": In actual use, if there are other decorators (such as ",(0,i.kt)("inlineCode",{parentName:"p"},"@Controller")," ), the ",(0,i.kt)("inlineCode",{parentName:"p"},"@Provide")," is often omitted."),(0,i.kt)("h2",{id:"dependency-injection-principle"},"Dependency injection principle"),(0,i.kt)("p",null,"Let's take the following pseudo code as an example. During the startup phase of Midway system, a dependency injection container (MidwayContainer) will be created, files in all user codes (src) will be scanned, and Class with ",(0,i.kt)("inlineCode",{parentName:"p"},"@Provide")," decorator will be saved to the container."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"/***** The following is Midway's internal code *****/\n\nconst container = new MidwayContainer();\ncontainer.bind(UserController);\ncontainer.bind(UserService);\n\n")),(0,i.kt)("p",null,"The dependency injection container here is similar to a Map. The key of the map is the identifier of the class (for example, ",(0,i.kt)("strong",{parentName:"p"},"the hump string of the class name")," ), and the value is the ",(0,i.kt)("strong",{parentName:"p"},"class itself"),"."),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://img.alicdn.com/imgextra/i3/O1CN01qRbFaS1dETlDbbrsl_!!6000000003704-2-tps-623-269.png",alt:"image.png"})),(0,i.kt)("p",null,"When requested, these Classes are dynamically instantiated and the assignment of attributes is handled, such as the pseudo code below, which is easy to understand."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"/***** The following is the dependency injection container pseudo code *****/\nconst userService = new UserService();\nconst userController = new UserController();\n\nuserController.userService = userService;\n")),(0,i.kt)("p",null,"After this, we can get the complete ",(0,i.kt)("inlineCode",{parentName:"p"},"userController")," object, and the actual code will be slightly different."),(0,i.kt)("p",null,"MidwayContainer have ",(0,i.kt)("inlineCode",{parentName:"p"},"getAsync")," methods for asynchronously processing the initialization of objects (many dependencies are required for asynchronous initialization), automatic attribute assignment, caching, returning objects, and combining the above processes into one."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"/***** The following is the internal code of the dependency injection container *****/\n\n// Automatic new UserService();\n// Automatic new UserController();\n// Automatic assignment userController.userService = await container.getAsync(UserService);\n\nconst userController = await container.getAsync(UserController);\nawait userController.handler(); // output 'world'\n")),(0,i.kt)("p",null,"The above is the core process of dependency injection, creating an instance."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"In addition, here is an article called ",(0,i.kt)("a",{parentName:"p",href:"https://mp.weixin.qq.com/s/g07BByYS6yD3QkLsA7zLYQ"},'"This time, I will teach you to write an IoC container from scratch"'),". Please read it more.")),(0,i.kt)("h2",{id:"dependency-injection-scope"},"Dependency injection scope"),(0,i.kt)("p",null,"If the default is unspecified or undeclared, the scope of all ",(0,i.kt)("inlineCode",{parentName:"p"},"@Provide")," classes is the ",(0,i.kt)("strong",{parentName:"p"},"request scope"),". This means that these Classes will be instantiated (new) at the first call of each request, and the instance will be destroyed after the request ends. **Our controller (Controller) and service (Service) by default are both in this scope."),(0,i.kt)("p",null,"In Midway's dependency injection system, there are three scopes."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},"Scope"),(0,i.kt)("th",{parentName:"tr",align:null},"Description"))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Singleton"),(0,i.kt)("td",{parentName:"tr",align:null},"Single instance, globally unique (process level)")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Request"),(0,i.kt)("td",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"td"},"Default"),": the scope of the request, the lifecycle of the request is bound to the ",(0,i.kt)("strong",{parentName:"td"},"request link"),". The instance is unique on the request link and destroyed immediately after the request ends.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"Prototype"),(0,i.kt)("td",{parentName:"tr",align:null},"Prototype scope, creating a new object repeatedly for each call")))),(0,i.kt)("p",null,"Different scopes have different functions, * ",(0,i.kt)("em",{parentName:"p"}," Singleton ")," can be used to do process-level data cache, or database connection and other tasks that only need to be performed once. at the same time, Singleton is only initialized once due to global uniqueness, so the calling speed is relatively fast. However, ",(0,i.kt)("strong",{parentName:"p"},"request scope")," is the choice of most services that need to obtain request parameters and data. ",(0,i.kt)("strong",{parentName:"p"},"prototype scope")," is less used and has its unique function in some special scenarios."),(0,i.kt)("h3",{id:"configure-scope"},"Configure scope"),(0,i.kt)("p",null,"If we need to define one object as the other two scopes, additional configuration is required. Midway provides a ",(0,i.kt)("inlineCode",{parentName:"p"},"@Scope")," decorator to define the scope of a class. The following code turns our user service into a globally unique instance."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"// service\nimport { Provide, Scope, ScopeEnum } from '@midwayjs/decorator';\n\n@Provide()\n@Scope(ScopeEnum.Singleton)\nexport class UserService {\n  //...\n}\n")),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Note that all entry classes, such as Controller, are request scopes and do not support modification. In most cases, only the Service needs to be adjusted.")),(0,i.kt)("h3",{id:"singleton-scope"},"Singleton scope"),(0,i.kt)("p",null,"After explicit configuration, the scope of a class can become a singleton scope. ."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"// service\nimport { Provide, Scope, ScopeEnum } from '@midwayjs/decorator';\n\n@Provide()\n@Scope(ScopeEnum.Singleton)\nexport class UserService {\n  //...\n}\n\n")),(0,i.kt)("p",null,"No matter how many times an instance of this class is obtained in the future, it will be the same instance under the same process."),(0,i.kt)("p",null,"For example, based on the above singleton service, the following two injected ",(0,i.kt)("inlineCode",{parentName:"p"},"userService")," attributes are the same instance:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"@Provide()\nexport class A {\n\n  @Inject()\n  userService: UserService\n  //...\n}\n\n@Provide()\nexport class B {\n\n  @Inject()\n  userService: UserService\n  //...\n}\n")),(0,i.kt)("h3",{id:"request-scope"},"Request scope"),(0,i.kt)("p",null,"By default, all classes written in the code are ",(0,i.kt)("strong",{parentName:"p"},"request scope"),"."),(0,i.kt)("p",null,"In each protocol entry framework, a dependency injection container under the request scope is automatically created, and all created instances are bound to the context of the current protocol."),(0,i.kt)("p",null,"For example:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"When an http request comes in, a request scope is created, and each Controller is dynamically created when the request is routed."),(0,i.kt)("li",{parentName:"ul"},"The timer is triggered, which is equivalent to creating a request scope ctx. We can get this request scope through @Inject()ctx.")),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"The default is the request scope for the purpose of associating with the request context. Explicitly passing ctx is more secure and reliable, and easy to debug.")),(0,i.kt)("p",null,"Therefore, in the request scope, we can use ",(0,i.kt)("inlineCode",{parentName:"p"},"@Inject()")," to inject the current ctx object."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import { Controller, Provide, Inject } from '@midwayjs/decorator';\nimport { Context } from '@midwayjs/koa';\n\n@Provide() // actually can be omitted\n@Controller('/user')\nexport class UserController {\n\n  @Inject()\n  ctx: Context;\n  //...\n}\n")),(0,i.kt)("p",null,"Our ",(0,i.kt)("inlineCode",{parentName:"p"},"@Inject")," decorator also looks for objects to inject under the ",(0,i.kt)("strong",{parentName:"p"},"scope")," of the current class. For example, in the ",(0,i.kt)("inlineCode",{parentName:"p"},"Singleton")," scope, it is incorrect to inject CTX because it is not associated with the request and there is no ",(0,i.kt)("inlineCode",{parentName:"p"},"CTX")," object by default."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"@Provide()\n@Scope(ScopeEnum.Singleton)\nexport class UserService {\n\n  @Inject()\n  ctx; // undefined\n  //...\n}\n")),(0,i.kt)("h3",{id:"scope-cache"},"Scope cache"),(0,i.kt)("p",null,"When the scope is set to a singleton (Singleton), the entire Class injected object has been fixed after the first instantiation, which means that the injected content in the singleton cannot be another scope."),(0,i.kt)("p",null,"Let's give an example."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"// This class is the default request scope (Request)\n@Provide() // Actually can be omitted\n@Controller()\nexport class HomeController {\n  @Inject()\n  userService: UserService;\n}\n\n\n// Set a single instance, the process level is unique.\n@Provide()\n@Scope(ScopeEnum.Singleton)\nexport class UserService {\n    async getUser() {\n    // ...\n  }\n}\n")),(0,i.kt)("p",null,"The situation of the call is as follows.\n",(0,i.kt)("img",{parentName:"p",src:"https://img.alicdn.com/imgextra/i1/O1CN01FN99rS1Xb1YydSFi0_!!6000000002941-2-tps-1110-388.png",alt:"image.png"})),(0,i.kt)("p",null,"In this case, no matter how many times the ",(0,i.kt)("inlineCode",{parentName:"p"},"HomeController")," is called, the ",(0,i.kt)("inlineCode",{parentName:"p"},"HomeController")," instance of each request is different, and the ",(0,i.kt)("inlineCode",{parentName:"p"},"UserService")," will be fixed."),(0,i.kt)("p",null,"Let's take another example to show whether the service injected in the singleton will still retain the original scope."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"The ",(0,i.kt)("inlineCode",{parentName:"p"},"DBManager")," here is specially set to the request scope to demonstrate the special scene.")),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://img.alicdn.com/imgextra/i1/O1CN01eAyxrC1xVEYzbNf9P_!!6000000006448-2-tps-1964-334.png",alt:"image.png"})),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"// This class is the default request scope (Request)\n@Provide()\nexport class HomeController {\n  @Inject()\n  userService: UserService;\n}\n\n\n// Set a single instance, the process level is unique.\n@Provide()\n@Scope(ScopeEnum.Singleton)\nexport class UserService {\n\n  @Inject()\n  dbManager: DBManager;\n\n  async getUser() {\n    // ...\n  }\n}\n\n// The scope is not set, and the default is the request scope (here is used to verify the scenario where all subsequent instances are cached under the single instance link)\n@Provide()\nexport class DBManager {\n}\n\n")),(0,i.kt)("p",null,"In this case, no matter how many times the ",(0,i.kt)("inlineCode",{parentName:"p"},"HomeController")," is called, the ",(0,i.kt)("inlineCode",{parentName:"p"},"HomeController")," instance of each request is different, and the ",(0,i.kt)("inlineCode",{parentName:"p"},"UserService")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"DBManager")," will be fixed."),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://img.alicdn.com/imgextra/i2/O1CN01UoLu1526stZQFhp1U_!!6000000007718-2-tps-1870-762.png",alt:"image.png"}),"\nSimply understood, a singleton is like a cache in ",(0,i.kt)("strong",{parentName:"p"},"which all dependent objects will be frozen and will not change.")),(0,i.kt)("h3",{id:"scope-downgrade"},"Scope downgrade"),(0,i.kt)("p",null,"As mentioned above, when a singleton scope is injected with a request scope object, the object instance of the request scope is solidified and a fixed instance is saved in the singleton cache."),(0,i.kt)("p",null,"In this case, the scope of the request becomes a single instance, and the ",(0,i.kt)("strong",{parentName:"p"},"scope is degraded")," occurs."),(0,i.kt)("p",null,"In daily development, this happens if you are not careful, such as calling services in middleware."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"// The following paragraph is an example of error\n\n@Provide()\nexport class UserService {\n  @Inject()\n  ctx: Context;\n\n  async getUser() {\n    const id = this.ctx.xxxx;\n    // ctx not found, will throw error\n  }\n}\n\n// Middleware is a singleton\n@Middleware()\nexport class ReportMiddleware implements IMiddleware<Context, NextFunction> {\n  @Inject()\n  userService: UserService; // The user service here is the request scope\n\n  resolve() {\n    return async(ctx, next) => {\n      await this.userService.getUser();\n      // ...\n    }\n  }\n}\n")),(0,i.kt)("p",null,"At this time, although ",(0,i.kt)("inlineCode",{parentName:"p"},"UserService")," can be injected into the middleware normally, it is actually injected as a singleton object instead of an object in the request scope, which will cause ",(0,i.kt)("inlineCode",{parentName:"p"},"ctx")," to be empty."),(0,i.kt)("p",null,"The memory object diagram at this time is:"),(0,i.kt)("p",null,(0,i.kt)("img",{parentName:"p",src:"https://img.alicdn.com/imgextra/i3/O1CN01SwATKb1zUtVUCaQGj_!!6000000006718-2-tps-1292-574.png",alt:null})),(0,i.kt)("p",null,"Instances of ",(0,i.kt)("inlineCode",{parentName:"p"},"UserService")," become different objects, one is an instance of singleton invocation (singleton, excluding ctx), and the other is an instance of normal request-scoped invocation (request-scoped, including ctx)."),(0,i.kt)("p",null,"In order to avoid this situation, by default, when injecting such errors, the framework will automatically throw an error named ",(0,i.kt)("inlineCode",{parentName:"p"},"MidwaySingletonInjectRequestError")," to prevent the program from executing."),(0,i.kt)("p",null,"If the user understands the risks involved and explicitly needs to call the request scope object in a singleton, the parameter of the scope decorator can be set to allow degradation."),(0,i.kt)("p",null,"In the ",(0,i.kt)("inlineCode",{parentName:"p"},"ctx")," field, determine the empty object."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import { Provide, Scope, ScopeEnum } from '@midwayjs/decorator';\n\n@Provide()\n@Scope(ScopeEnum.Request, { allowDowngrade: true })\nexport class UserService {\n  @Inject()\n  ctx: Context;\n\n  async getUser() {\n    if (ctx && ctx.xxxx) {\n      // ...\n    }\n        // ...\n  }\n}\n")),(0,i.kt)("p",null,"Of course, if it is just a mistake, then you can use dynamic acquisition methods to make the scope uniform."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import { IMiddleware } from '@midwayjs/core';\nimport { Middleware } from '@midwayjs/decorator';\nimport { NextFunction, Context } from '@midwayjs/koa';\n\n@Middleware()\nexport class ReportMiddleware implements IMiddleware<Context, NextFunction> {\n\n  resolve() {\n    return async (ctx: Context, next: NextFunction) => {\n      const userService = await ctx.requestContext.getAsync(UserService);\n        // TODO userService.xxxx\n      await next();\n    };\n  }\n}\n")),(0,i.kt)("h2",{id:"injection-rule"},"Injection rule"),(0,i.kt)("p",null,"Midway supports injection in many ways."),(0,i.kt)("h3",{id:"class-based-injection"},"Class-based injection"),(0,i.kt)("p",null,"Export a Class, the type of injection uses Class, which is the simplest way to inject, and most businesses and components use this way."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import { Provide, Inject } from '@midwayjs/decorator';\n\n@Provide() // <------ Expose a Class\nexport class B {\n  //...\n}\n\n@Provide()\nexport class A {\n\n  @Inject()\n  B: B; // <------ The attribute here uses Class\n\n  //...\n}\n")),(0,i.kt)("p",null,"Midway will automatically use B as the type of the attribute B and instantiate it in the container."),(0,i.kt)("p",null,"In this case, Midway automatically creates a unique uuid to associate with the class. This uuid is called a ",(0,i.kt)("strong",{parentName:"p"},"dependency injection identifier"),"."),(0,i.kt)("p",null,"Default:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"@Provide")," will automatically generate a uuid as the dependency injection identifier"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("ol",{parentName:"li",start:2},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("inlineCode",{parentName:"li"},"@Inject")," searches for the uuid of the type.")))),(0,i.kt)("p",null,"If you want to get this uuid, you can use the following API."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import { getProviderUUId } from '@midwayjs/decorator';\n\nconst uuid = getProviderUUId(B);\n// ...\n")),(0,i.kt)("h3",{id:"injection-based-on-fixed-name"},"Injection Based on fixed name"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import { Provide, Inject } from '@midwayjs/decorator';\n\n@Provide ('BBB') // <------ Expose a Class\nexport class B {\n  //...\n}\n\n@Provide()\nexport class A {\n\n  @Inject('bbbb')\n  B: B; // <------ The attribute here uses Class\n\n  //...\n}\n")),(0,i.kt)("p",null,"Midway uses ",(0,i.kt)("inlineCode",{parentName:"p"},"bbbb")," as the dependency injection identifier for Class B and instantiates it in the container. In this case, even if type B is written, the dependency injection container will still search for ",(0,i.kt)("inlineCode",{parentName:"p"},"bbbb"),"."),(0,i.kt)("p",null,"The parameters of ",(0,i.kt)("inlineCode",{parentName:"p"},"@Provide")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"@Inject")," decorators appear in pairs."),(0,i.kt)("p",null,"The rules are as follows:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("ol",{parentName:"li"},(0,i.kt)("li",{parentName:"ol"},"If the decorator contains parameters, the ",(0,i.kt)("strong",{parentName:"li"},"parameter")," is used as the dependency injection identifier."))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("ol",{parentName:"li",start:2},(0,i.kt)("li",{parentName:"ol"},"If there are no parameters and the marked TS type is Class, the key of class ",(0,i.kt)("inlineCode",{parentName:"li"},"@Provide")," is taken as the key. If there is no key, uuid is taken by default"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("ol",{parentName:"li",start:3},(0,i.kt)("li",{parentName:"ol"},"If there is no parameter and the marked TS type is not Class, use the ",(0,i.kt)("strong",{parentName:"li"},"attribute name")," as the key.")))),(0,i.kt)("h3",{id:"injection-based-on-attribute-name"},"Injection Based on Attribute Name"),(0,i.kt)("p",null,"Midway can also inject based on the interface, but since the Typescirpt will remove the interface type after compilation, it is better to use the class as a definition."),(0,i.kt)("p",null,"For example, we define an interface and its implementation class."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"export interface IPay {\n  payMoney()\n}\n\n@Provide('APay')\nexport class A implements IPay {\n  async payMoney() {\n    // ...\n  }\n}\n\n@Provide('BPay')\nexport class B implements IPay {\n  async payMoney() {\n    // ...\n  }\n}\n")),(0,i.kt)("p",null,"At this time, if there is a service that needs to be injected, you can use the following explicit declaration."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"@Provide()\nexport class PaymentService {\n\n  @Inject('APay')\n  payService: IPay; // Note that the type here is an interface, and the type information will be removed after compilation.\n\n  async orderGood() {\n    await this.payService.payMoney();\n  }\n\n}\n")),(0,i.kt)("p",null,"Because the interface type is removed, Midway can only use the ",(0,i.kt)("strong",{parentName:"p"},"parameter")," or ",(0,i.kt)("strong",{parentName:"p"},"attribute name")," class of the ",(0,i.kt)("inlineCode",{parentName:"p"},"@Inject")," decorator to match the injected object information, similar to the ",(0,i.kt)("inlineCode",{parentName:"p"},"Autowire by name")," in Java Spring."),(0,i.kt)("h3",{id:"inject-existing-objects"},"Inject existing objects"),(0,i.kt)("p",null,"Sometimes, applications already have existing instances instead of classes. For example, a third library is introduced. At this time, if you want objects to be referenced by instances in other IoC containers, you can also add objects to handle them."),(0,i.kt)("p",null,"Let's take the common tool class library lodash as an example."),(0,i.kt)("p",null,"If we want to inject it directly in different classes, instead of require."),(0,i.kt)("p",null,"You need to add this object through the ",(0,i.kt)("inlineCode",{parentName:"p"},"registerObject")," method before the business call (usually during the startup life cycle)."),(0,i.kt)("p",null,"A ",(0,i.kt)("strong",{parentName:"p"},"dependency injection identifier")," is required to facilitate injection in other classes."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"// src/configuration.ts\nimport * as lodash from 'lodash';\nimport { Configuration } from '@midwayjs/decorator';\nimport { IMidwayContainer } from '@midwayjs/core';\n\n@Configuration()\nexport class AutoConfiguration {\n\n  async onReady(applicationContext: IMidwayContainer) {\n        // Add some global objects to the dependency injection container\n    applicationContext.registerObject('lodash', lodash);\n  }\n}\n\n")),(0,i.kt)("p",null,"At this time, you can use ",(0,i.kt)("inlineCode",{parentName:"p"},"@Inject")," in any class."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"@Provide()\nexport class BaseService {\n\n  @Inject('lodash')\n  lodashTool;\n\n  async getUser() {\n    // this.lodashTool.defaults({ 'a': 1 }, { 'a': 3, 'B ': 2 });\n  }\n}\n")),(0,i.kt)("h3",{id:"inject-default-identifier"},"Inject default identifier"),(0,i.kt)("p",null,"Midway injects some values by default to facilitate direct business use."),(0,i.kt)("table",null,(0,i.kt)("thead",{parentName:"table"},(0,i.kt)("tr",{parentName:"thead"},(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"th"},"Identifier")),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"th"},"Value Type")),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"th"},"Scope")),(0,i.kt)("th",{parentName:"tr",align:null},(0,i.kt)("strong",{parentName:"th"},"Description")))),(0,i.kt)("tbody",{parentName:"table"},(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"baseDir"),(0,i.kt)("td",{parentName:"tr",align:null},"string"),(0,i.kt)("td",{parentName:"tr",align:null},"Global"),(0,i.kt)("td",{parentName:"tr",align:null},"The src directory is developed locally, otherwise it is dist directory.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"appDir"),(0,i.kt)("td",{parentName:"tr",align:null},"string"),(0,i.kt)("td",{parentName:"tr",align:null},"Global"),(0,i.kt)("td",{parentName:"tr",align:null},"The root path of the application is generally process.cwd()")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"ctx"),(0,i.kt)("td",{parentName:"tr",align:null},"object"),(0,i.kt)("td",{parentName:"tr",align:null},"Request"),(0,i.kt)("td",{parentName:"tr",align:null},"The context type of the corresponding framework, such as the Context of Koa and EggJS, and the req of the Express.")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"logger"),(0,i.kt)("td",{parentName:"tr",align:null},"object"),(0,i.kt)("td",{parentName:"tr",align:null},"Request"),(0,i.kt)("td",{parentName:"tr",align:null},"Equivalent to ctx.logger")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"req"),(0,i.kt)("td",{parentName:"tr",align:null},"object"),(0,i.kt)("td",{parentName:"tr",align:null},"Request"),(0,i.kt)("td",{parentName:"tr",align:null},"Unique to Express")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"res"),(0,i.kt)("td",{parentName:"tr",align:null},"object"),(0,i.kt)("td",{parentName:"tr",align:null},"Request"),(0,i.kt)("td",{parentName:"tr",align:null},"Unique to Express")),(0,i.kt)("tr",{parentName:"tbody"},(0,i.kt)("td",{parentName:"tr",align:null},"socket"),(0,i.kt)("td",{parentName:"tr",align:null},"object"),(0,i.kt)("td",{parentName:"tr",align:null},"Request"),(0,i.kt)("td",{parentName:"tr",align:null},"WebSocket scenes are unique")))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"@Provide()\nexport class BaseService {\n\n  @Inject()\n  baseDir;\n\n  @Inject()\n  appDir;\n\n  async getUser() {\n    console.log(this.baseDir);\n    console.log(this.appDir);\n  }\n}\n")),(0,i.kt)("h2",{id:"get-the-dependency-injection-container"},"Get the dependency injection container"),(0,i.kt)("p",null,"In general, users do not need to care about relying on injection containers, but in some special scenarios, such"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"The service needs to be called dynamically, such as the middleware scenario of the Web, and the service needs to be called during the startup phase."),(0,i.kt)("li",{parentName:"ul"},"The encapsulation framework or other tripartite SDKs require dynamic access to services.")),(0,i.kt)("p",null,"Simply put, in any scenario where you need to ",(0,i.kt)("strong",{parentName:"p"},"dynamically obtain services through API operations"),", you must first obtain the dependency injection container."),(0,i.kt)("h3",{id:"get-from-applicationcontext-decorator"},"Get from @ApplicationContext() decorator"),(0,i.kt)("p",null,"In the new version, Midway provides a @ApplicationContext() decorator to get the dependency injection container."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import { ApplicationContext } from '@midwayjs/decorator';\nimport { IMidwayContainer } from '@midwayjs/core';\n\n@Provide()\nexport class BootApp {\n\n  @ApplicationContext()\n  applicationContext: IMidwayContainer; // You can also replace it with the app definition of the actual framework here.\n\n  async invoke() {\n\n    // this.applicationContext\n\n  }\n\n}\n")),(0,i.kt)("h3",{id:"get-from-app"},"Get from app"),(0,i.kt)("p",null,"Midway mounts the dependent injection container in two places, the app of the framework and the context Context of each request. Due to the different situations of different upper-level frameworks, let's list common examples here."),(0,i.kt)("p",null,"For different upper-level frameworks, we provide a unified definition of ",(0,i.kt)("inlineCode",{parentName:"p"},"IMidwayApplication"),". All upper-level framework apps will implement this interface, which is defined as follows."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"export interface IMidwayApplication {\n  getApplicationContext(): IMidwayContainer;\n  //...\n}\n")),(0,i.kt)("p",null,"That is, through the ",(0,i.kt)("inlineCode",{parentName:"p"},"app.getApplicationContext()")," method, we can all obtain the dependency injection container."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"const container = app.getApplicationContext();\n")),(0,i.kt)("p",null,"With the ",(0,i.kt)("inlineCode",{parentName:"p"},"@App")," decorator, you can easily access the currently running app instance anywhere."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import { App } from '@midwayjs/decorator';\nimport { IMidwayApplication } from '@midwayjs/core';\n\n@Provide()\nexport class BootApp {\n\n  @App()\n  app: IMidwayApplication; //You can also replace it with the app definition of the actual framework here.\n\n  async invoke() {\n\n    // Get the dependency injection container\n    const applicationContext = this.app.getApplicationContext();\n\n  }\n\n}\n")),(0,i.kt)("p",null,"In addition to the common dependency injection container, Midway also provides a ",(0,i.kt)("strong",{parentName:"p"},"dependency injection container for the request link.")," The dependency injection container for this request link is associated with a global dependency injection container and shares an object pool. But there is still a difference between the two."),(0,i.kt)("p",null,"The dependency injection container of the request link is used to obtain the objects of the specific request scope. The objects obtained in this container are ",(0,i.kt)("strong",{parentName:"p"},"bound to the request")," and are associated with the current context. This means that ",(0,i.kt)("strong",{parentName:"p"},"if the Class code is associated with the request, it must be obtained from the dependency injection container of the request link"),"."),(0,i.kt)("p",null,"The dependency injection container of the request link must be obtained from the request context object. The most common scenario is web middleware."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"@Middleware()\nexport class ReportMiddleware {\n\n  resolve() {\n    return async(ctx, next) => {\n      // ctx. Dependency Injection Container for requestContext Request Link\n      await next();\n    }\n  }\n}\n")),(0,i.kt)("p",null,"The Express request link depends on the injection container mounted on the req object."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"@Middleware()\nexport class ReportMiddleware {\n\n  resolve() {\n    return (req, res, next) => {\n      // req. Dependency Injection Container for requestContext Request Link\n      next();\n    }\n  }\n}\n")),(0,i.kt)("h3",{id:"get-in-configuration"},"Get in Configuration"),(0,i.kt)("p",null,"In the life cycle of the code entry ",(0,i.kt)("inlineCode",{parentName:"p"},"configuration")," file, we will also pass additional parameters that depend on the injection container, which is convenient for users to use directly."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"// src/configuration.ts\nimport { Configuration } from '@midwayjs/decorator';\nimport { IMidwayContainer } from '@midwayjs/core';\n\n@Configuration()\nexport class AutoConfiguration {\n  async onReady(applicationContext: IMidwayContainer) {\n    // ...\n  }\n}\n")),(0,i.kt)("h2",{id:"dynamic-api"},"Dynamic API"),(0,i.kt)("h3",{id:"dynamic-acquisition-of-instances"},"Dynamic acquisition of instances"),(0,i.kt)("p",null,"After you get the ",(0,i.kt)("strong",{parentName:"p"},"dependency injection container")," or ",(0,i.kt)("strong",{parentName:"p"},"dependency of the request link")," injection container, you can obtain the object through the container API."),(0,i.kt)("p",null,"We can use the standard dependency injection container API to obtain instances."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"// The global container is obtained as a singleton.\nconst userSerivce = await applicationContext.getAsync(UserService);\n\n// Request scope container, get the request scope instance.\nconst userSerivce = await ctx.requestContext.getAsync(UserService);\n")),(0,i.kt)("p",null,"We can use it wherever we can get dependent injection containers, such as in middleware."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import { Middleware, ApplicationContext } from '@midwayjs/decorator';\nimport { NextFunction, Context } from '@midwayjs/koa';\nimport { IMiddleware } from '@midwayjs/core';\nimport { UserService } from './service/user.service';\n\n@Middleware()\nexport class ReportMiddleware implements IMiddleware<Context, NextFunction> {\n  @ApplicationContext()\n  applicationContext: IMidwayContainer;\n\n  resolve() {\n    return async(ctx, next) => {\n      // Specify a generic type, such as an interface\n      const userService1 = await this.applicationContext.getAsync<UserService>(UserService);\n      // You can deduce the correct type without writing generics.\n      const userService1 = await this.applicationContext.getAsync(UserService);\n\n      // The following method obtains the service and request association, which can be injected into the context.\n      const userService2 = await ctx.requestContext.getAsync<UserService>(UserService);\n      await next();\n    }\n  }\n}\n")),(0,i.kt)("p",null,"In Express."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import { UserService, Middleware } from './service/user';\nimport { NextFunction, Context, Response } from '@midwayjs/express';\n\n@Middleware()\nexport class ReportMiddleware implements IMiddleware<Context, Response, NextFunction> {\n\n  resolve() {\n    return async (req, res, next) => {\n      const userService = await req.requestContext.getAsync<UserService>(UserService);\n      // ...\n      next();\n    }\n  }\n}\n")),(0,i.kt)("h3",{id:"pass-constructor-parameters"},"Pass constructor parameters"),(0,i.kt)("p",null,"In individual scenarios, we can pass the constructor parameters when we get the instance through the ",(0,i.kt)("inlineCode",{parentName:"p"},"getAsync"),". Normal decorator mode cannot be done, only available in API form."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"@Provide()\nclass UserService {\n  constructor(private readonly type) {}\n\n  getUser() {\n    // this.type => student\n  }\n}\n\n// The global container is obtained as a singleton.\nconst userSerivce = await applicationContext.getAsync(UserService, [\n  'student', // constructor parameters, will apply to the constructor\n]);\n\n// Request scope container, get the request scope instance.\nconst userSerivce = await ctx.requestContext.getAsync(UserService, [\n  'student'\n]);\n")),(0,i.kt)("p",null,"Note that the constructor cannot pass instances in injection form, but can only pass fixed values."),(0,i.kt)("h3",{id:"dynamic-function-injection"},"Dynamic function injection"),(0,i.kt)("p",null,"In some scenarios, we need functions to be executed dynamically as a logic, while the object properties in the dependent injection container are already created and cannot meet the dynamic logic requirements."),(0,i.kt)("p",null,"For example, you need a factory function to return different instances according to different scenarios, or you may have a three-party package, which is a function that you want to call directly in the business. In various scenarios, you need to inject a factory method directly, get the context in the function, and dynamically generate the instance."),(0,i.kt)("p",null,"The following is a sample of the standard factory method injection."),(0,i.kt)("p",null,"General factory methods are used to return the implementation of the same interface, for example, we have two ",(0,i.kt)("inlineCode",{parentName:"p"},"ICacheService")," interface implementations:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"export interface ICacheService {\n  getData(): any;\n}\n\n@Provide()\nexport class LocalCacheService implements ICacheService {\n  async getData {}\n}\n\n@Provide()\nexport class RemoteCacheService implements ICacheService {\n  async getData {}\n}\n")),(0,i.kt)("p",null,"Then you can define a dynamic service (factory) and return different implementations according to the current user configuration."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"// src/service/dynamicCacheService.ts\n\nimport { providerWrapper, IMidwayContainer } from '@midwayjs/core';\n\nexport async function dynamicCacheServiceHandler(container: IMidwayContainer) {\n    // Get global configuration from container API\n  const config = container.getConfigService().getConfiguration();\n  if (config['redis']['mode'] === 'local') {\n    return await container.getAsync('localCacheService');\n  } else {\n    return await container.getAsync('remoteCacheService');\n  }\n}\n\nproviderWrapper ([\n  {\n    id: 'dynamicCacheService',\n    provider: dynamicCacheServiceHandler\n    Scope: ScopeEnum.Request, // is set to the request scope, then the container passed in above is the request scope container.\n    // scope: ScopeEnum.Singleton, // can also be set to global scope, then the logic of the call will be cached\n  }\n]);\n")),(0,i.kt)("p",null,"In this way, it can be used directly in business. Note: When injecting, the method is ",(0,i.kt)("strong",{parentName:"p"},"called and then injected"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"@Provide()\n@Controller('/')\nexport class HomeController {\n\n  @Inject()\n  ctx: Context;\n\n  @Inject('dynamicCacheServiceHandler')\n  cacheService: ICacheService;\n\n  @Get('/')\n  async home() {\n    const data = await this.cacheService.getData();\n    // ...\n  }\n\n}\n")),(0,i.kt)("p",null,"By ",(0,i.kt)("inlineCode",{parentName:"p"},"providerWrapper"),", we have wrapped an original function writing method, which can be integrated with the existing dependency injection system, so that the container can be managed uniformly."),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"Note that dynamic methods must be exported before they are scanned by dependency injection. The default is the request scope (the Container obtained is the request scope container).")),(0,i.kt)("p",null,"Since we can bind the dynamic method to the dependency injection container, we can also bind a callback method in, so that the obtained method can be executed, and we can determine the returned result based on the parameters of the business."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import { providerWrapper, IMidwayContainer } from '@midwayjs/core';\n\nexport function cacheServiceHandler(container: IMidwayContainer) {\n  return async (mode: string) => {\n    if (mode === 'local') {\n      return await container.getAsync('localCacheService');\n    } else {\n      return await container.getAsync('remoteCacheService');\n    }\n  };\n}\n\nproviderWrapper ([\n  {\n    id: 'cacheServiceHandler',\n    provider: cacheServiceHandler\n    scope: ScopeEnum.Singleton\n  }\n]);\n\n\n@Provide()\n@Controller('/')\nexport class HomeController {\n\n  @Inject()\n  ctx: Context;\n\n  @Inject('cacheServiceHandler')\n  getCacheService;\n\n  @Get('/')\n  async home() {\n    const data = await this.getCacheService('local');\n    // ...\n  }\n\n}\n")),(0,i.kt)("h2",{id:"static-api"},"Static API"),(0,i.kt)("p",null,"In some tool classes, you can obtain the global dependency injection container (",(0,i.kt)("strong",{parentName:"p"},"after startup"),") without creating a class instance."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import { getCurrentApplicationContext } from '@midwayjs/core';\n\nexport const getService = async (serviceName) => {\n  return getCurrentApplicationContext().getAsync(serviceName);\n}\n")),(0,i.kt)("p",null,"Gets the main frame ",(0,i.kt)("strong",{parentName:"p"},"after startup"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import { getCurrentMainFramework } from '@midwayjs/core';\n\nexport const framework = () => {\n  return getCurrentMainFramework();\n}\n")),(0,i.kt)("p",null,"Gets the app object of the main frame ",(0,i.kt)("strong",{parentName:"p"},"after startup"),"."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"import { getCurrentMainApp } from '@midwayjs/core';\n\nexport const getGlobalConfig = () => {\n  return getCurrentMainApp().getConfig();\n}\n")),(0,i.kt)("h2",{id:"automatic-binding"},"Automatic binding"),(0,i.kt)("p",null,"As mentioned above, after the container is initialized, we will bind the existing class registration to the container."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"const container = new MidwayContainer();\ncontainer.bind(UserController);\ncontainer.bind(UserService);\n")),(0,i.kt)("p",null,"Midway will automatically scan the entire project directory during the startup process and automatically process this behavior, so that the user does not need to manually perform binding operations."),(0,i.kt)("p",null,"Simply put, the framework will recursively scan the ts/js files in the entire ",(0,i.kt)("inlineCode",{parentName:"p"},"src")," directory by default, and then perform require operations. When the file is exported as a class and explicitly or implicitly contains the ",(0,i.kt)("inlineCode",{parentName:"p"},"@Provide()")," decorator, it will execute the ",(0,i.kt)("inlineCode",{parentName:"p"},"container.bind")," logic."),(0,i.kt)("p",null,"In general, we should not put non-ts files under src (such as front-end code). In special scenarios, we can ignore some directories and configure them in the ",(0,i.kt)("inlineCode",{parentName:"p"},"@Configuration")," decorator."),(0,i.kt)("p",null,"An example is as follows:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"// src/configuration.ts\nimport { App, Configuration, Logger } from '@midwayjs/decorator';\n// ...\n\n@Configuration({\n  // ...\n  detectorOptions: {\n    ignore: [\n      '**/web/**'\n    ]\n  }\n})\nexport class ContainerLifeCycle {\n  // ...\n}\n\n")),(0,i.kt)("h2",{id:"object-lifecycle"},"Object lifecycle"),(0,i.kt)("p",null,"When creating and destroying instances depending on the injection container, we can use the decorator to do some custom operations."),(0,i.kt)("h3",{id:"asynchronous-initialization"},"Asynchronous initialization"),(0,i.kt)("p",null,"In some cases, we need an instance to be initialized before being called by other dependencies. If this initialization only reads a certain file, it can be written as a synchronization method. If this initialization is to take data from a remote end or connect to a certain service, in this case, ordinary synchronization code is very difficult to write."),(0,i.kt)("p",null,"Midway provides asynchronous initialization. You can use the ",(0,i.kt)("inlineCode",{parentName:"p"},"@Init")," tag to manage initialization methods."),(0,i.kt)("p",null,"Only one ",(0,i.kt)("inlineCode",{parentName:"p"},"@Init")," method can be used."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"@Provide()\nexport class BaseService {\n\n  @Config('hello')\n  config;\n\n  @Init()\n  async init() {\n    await new Promise(resolve => {\n      setTimeout(() => {\n        this.config.c = 10;\n        resolve();\n      }, 100);\n    });\n  }\n\n}\n")),(0,i.kt)("p",null,"Equivalent"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"const service = new BaseService();\nawait service.init();\n")),(0,i.kt)("admonition",{type:"info"},(0,i.kt)("p",{parentName:"admonition"},"The method marked by the @Init decorator will definitely be called asynchronously. In general, asynchronous initialization of services is slow, please label it as a singleton (@Scope(ScopeEnum.Singleton)) as much as possible.")),(0,i.kt)("h3",{id:"asynchronous-destruction"},"Asynchronous destruction"),(0,i.kt)("p",null,"Midway provides the ability to execute methods before objects are destroyed and manages methods through the ",(0,i.kt)("inlineCode",{parentName:"p"},"@Destroy")," decorator."),(0,i.kt)("p",null,"There is currently only one ",(0,i.kt)("inlineCode",{parentName:"p"},"@Destroy")," method."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"@Provide()\nexport class BaseService {\n\n  @Config('hello')\n  config;\n\n  @Destroy()\n  async stop() {\n    // do something\n  }\n}\n")),(0,i.kt)("h2",{id:"common-usage-errors"},"Common usage errors"),(0,i.kt)("h3",{id:"error-get-injection-property-in-constructor"},"Error: Get Injection Property in Constructor"),(0,i.kt)("p",null,"Please do not get the injected attribute in the constructor * *, which will make the result undefined. The reason is that the properties injected by the decorator are assigned only after the instance is created (new). In this case, use the ",(0,i.kt)("inlineCode",{parentName:"p"},"@Init")," decorator."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-typescript"},"@Provide()\nexport class UserService {\n\n  @Config('userManager')\n  userManager;\n\n  constructor() {\n    console.log(this.userManager); // undefined\n  }\n\n  @Init()\n  async initMethod() {\n    console.log(this.userManager); // has value\n  }\n\n}\n")),(0,i.kt)("h3",{id:"on-inheritance"},"On inheritance"),(0,i.kt)("p",null,"To avoid property confusion, do not use the ",(0,i.kt)("inlineCode",{parentName:"p"},"@Provide")," decorator on the base class."),(0,i.kt)("p",null,"At this stage, Midway supports the inheritance of attribute decorators, but does not support the inheritance of class and method decorators (there will be ambiguity)."))}d.isMDXComponent=!0}}]);